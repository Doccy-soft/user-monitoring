<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Capture</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <!-- Login Page -->
    <div id="login-page" class="bg-white p-8 rounded-lg shadow-md w-96">
        <div class="text-center mb-6">
            <div class="w-16 h-16 bg-blue-500 rounded-full mx-auto flex items-center justify-center">
                <img src="doccy.gif" alt="Doccy Logo" class="w-29 h-29">
            </div>
            <h1 class="text-2xl font-bold mt-4">Doccy</h1>
            <p class="text-gray-600">Record and send audio to your desktop</p>
        </div>
        <div>
            <label for="username" class="block text-gray-700 mb-2">Username</label>
            <input type="text" id="username" class="w-full p-2 border rounded mb-4" placeholder="Enter your username">
            <button id="continue-btn" class="w-full text-white p-2 rounded" style="background-color: #132792;">Continue</button>
        </div>
    </div>

    <!-- Recording Page -->
    <div id="recording-page" class="hidden bg-white p-8 rounded-lg shadow-md w-96">
        <div class="flex justify-between mb-4">
            <span id="login-status" class="text-sm">Logged in as <span id="logged-username"></span></span>
            <button id="logout-btn" class="text-sm text-black">Logout ‚Üí</button>
        </div>
        <h2 class="text-xl font-bold mb-2">Audio Recorder</h2>
        <p class="text-gray-600 mb-4">Tap to begin recording</p>
        <canvas id="wave-canvas" class="w-full h-32 bg-gray-200 mb-4"></canvas>
        <div class="flex space-x-2">
            <button id="record-btn" class="flex-1 text-white p-2 rounded flex items-center justify-center" style="background-color: #132792;">
                <span class="mr-2">üéôÔ∏è</span> Record
            </button>
            <button id="save-btn" class="flex-1 text-white p-2 rounded" style="background-color: #132792;" disabled>Save</button>
        </div>
        <p class="text-sm text-gray-600 mt-4">Your recordings will be saved as <span id="filename"></span> on your desktop.</p>
        <p id="https-warning" class="text-sm text-red-600 mt-2 hidden">Recording is not supported on mobile devices without HTTPS. Please access this site over HTTPS or use a desktop browser.</p>
    </div>

    <!-- Save Recording Dialog -->
    <div id="save-dialog" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg w-80">
            <h3 class="text-lg font-bold mb-4">Save Recording</h3>
            <input type="text" id="recording-name" class="w-full p-2 border rounded mb-4" placeholder="Enter recording name">
            <div class="flex space-x-2">
                <button id="confirm-save" class="flex-1 text-white p-2 rounded" style="background-color: #132792;">Save</button>
                <button id="cancel-save" class="flex-1 text-gray-700 p-2 rounded border">Cancel</button>
            </div>
        </div>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const wsUrl = "wss://0igt7rsq5c.execute-api.us-east-1.amazonaws.com/production";
        const bucketName = "sound-capture-uploads";
        const loginPage = document.getElementById('login-page');
        const recordingPage = document.getElementById('recording-page');
        const continueBtn = document.getElementById('continue-btn');
        const usernameInput = document.getElementById('username');
        const recordBtn = document.getElementById('record-btn');
        const saveBtn = document.getElementById('save-btn');
        const waveCanvas = document.getElementById('wave-canvas');
        const filenameSpan = document.getElementById('filename');
        const logoutBtn = document.getElementById('logout-btn');
        const loggedUsername = document.getElementById('logged-username');
        const httpsWarning = document.getElementById('https-warning');
        const saveDialog = document.getElementById('save-dialog');
        const recordingNameInput = document.getElementById('recording-name');
        const confirmSaveBtn = document.getElementById('confirm-save');
        const cancelSaveBtn = document.getElementById('cancel-save');
        let username;
        let ws;
        let audioContext;
        let analyser;
        let processor;
        let isRecording = false;
        let reconnectAttempts = 0;
        const baseReconnectDelay = 200;
        let micStream = null;
        let sourceNode;
        let collectedFrames = [];
        const silenceThreshold = 0.02;
        const silenceDurationThreshold = 400;
        let silenceStart = null;
        let silenceDetected = false;

        // Check for HTTPS and mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (location.protocol !== 'https:' && isMobile) {
            console.error('This page must be served over HTTPS to access the microphone on mobile devices.');
            httpsWarning.classList.remove('hidden');
            recordBtn.disabled = true;
            saveBtn.disabled = true;
        }

        // Initialize
        function initialize() {
            username = localStorage.getItem('username');
            if (username) {
                loginPage.classList.add('hidden');
                recordingPage.classList.remove('hidden');
                loggedUsername.textContent = username;
                filenameSpan.textContent = `${username}_date.wav`;
                // Check for existing microphone permission
                if (localStorage.getItem('micPermission') === 'granted') {
                    setupMicrophone();
                }
            }
        }

        // Setup microphone once
        async function setupMicrophone() {
            try {
                if (!micStream) {
                    micStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            sampleSize: 16
                        }
                    });
                    console.log('Microphone stream created:', micStream);
                    localStorage.setItem('micPermission', 'granted');
                    // Monitor permission changes
                    navigator.permissions.query({ name: 'microphone' }).then(permissionStatus => {
                        permissionStatus.onchange = () => {
                            if (permissionStatus.state === 'granted') {
                                localStorage.setItem('micPermission', 'granted');
                            } else {
                                localStorage.removeItem('micPermission');
                                if (micStream) {
                                    micStream.getTracks().forEach(track => track.stop());
                                    micStream = null;
                                }
                            }
                        };
                    });
                }
            } catch (err) {
                console.error('Error accessing microphone:', err);
                localStorage.removeItem('micPermission');
                alert('Failed to access microphone. Please ensure you have granted microphone permissions.');
            }
        }

        // Handle login
        continueBtn.addEventListener('click', () => {
            username = usernameInput.value.trim();
            if (username) {
                localStorage.setItem('username', username);
                loginPage.classList.add('hidden');
                recordingPage.classList.remove('hidden');
                loggedUsername.textContent = username;
                filenameSpan.textContent = `${username}_date.wav`;
                setupMicrophone();
            } else {
                alert('Please enter a username.');
            }
        });

        // Handle logout
        logoutBtn.addEventListener('click', () => {
            if (ws) ws.close();
            localStorage.removeItem('username');
            localStorage.removeItem('micPermission');
            recordingPage.classList.add('hidden');
            loginPage.classList.remove('hidden');
            usernameInput.value = '';
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                micStream = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            isRecording = false;
            collectedFrames = [];
            silenceStart = null;
            silenceDetected = false;
            saveBtn.disabled = true;
        });

        // Connect to WebSocket
        function connectWebSocket() {
            const fullWsUrl = `${wsUrl}?username=${username}&deviceType=mobile`;
            ws = new WebSocket(fullWsUrl);
            ws.onopen = () => {
                console.log('Connected to', fullWsUrl);
                reconnectAttempts = 0;
            };
            ws.onerror = (error) => {
                console.error('WebSocket error:', error, fullWsUrl);
                console.error('This may be due to CORS issues. Ensure the WebSocket server allows connections from your static site domain.');
            };
            ws.onclose = () => {
                console.log('WebSocket closed');
                if (isRecording) {
                    const delay = baseReconnectDelay * Math.pow(1.5, reconnectAttempts);
                    console.log(`Attempting to reconnect in ${delay}ms...`);
                    setTimeout(() => {
                        reconnectAttempts++;
                        connectWebSocket();
                    }, delay);
                } else {
                    console.log('Recording stopped, no further reconnection attempts');
                }
            };
        }

        // Handle recording
        recordBtn.addEventListener('click', async () => {
            if (!audioContext) {
                audioContext = new AudioContext({ sampleRate: 16000 });
                console.log('AudioContext created');
            }
            if (audioContext.state === 'suspended') {
                try {
                    await audioContext.resume();
                    console.log('AudioContext resumed successfully');
                } catch (err) {
                    console.error('Failed to resume AudioContext:', err);
                    alert('Unable to start audio context. Please try again.');
                    return;
                }
            }
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;

            if (!micStream && localStorage.getItem('micPermission') !== 'granted') {
                await setupMicrophone();
                if (!micStream) return;
            }

            try {
                sourceNode = audioContext.createMediaStreamSource(micStream);
                processor = audioContext.createScriptProcessor(4096, 1, 1);
                sourceNode.connect(processor);
                processor.connect(audioContext.destination);
                sourceNode.connect(analyser);
                console.log('Audio pipeline connected');

                collectedFrames = [];
                silenceStart = null;
                silenceDetected = false;

                processor.onaudioprocess = (e) => {
                    if (!isRecording) return;
                    const inputData = e.inputBuffer.getChannelData(0);
                    const samples = new Float32Array(inputData);

                    let sum = 0;
                    for (let i = 0; i < samples.length; i++) {
                        sum += Math.abs(samples[i]);
                    }
                    const meanAbs = sum / samples.length;
                    const isSilent = meanAbs < silenceThreshold;

                    if (isSilent) {
                        if (!silenceDetected) {
                            silenceStart = Date.now();
                            silenceDetected = true;
                        }
                    } else {
                        silenceDetected = false;
                        silenceStart = null;
                        collectedFrames.push(...samples);
                    }

                    const silenceDuration = silenceDetected ? (Date.now() - silenceStart) : 0;

                    if (silenceDuration >= silenceDurationThreshold && collectedFrames.length > 0) {
                        const duration = (collectedFrames.length / audioContext.sampleRate);
                        console.log(`Uploading audio - Duration: ${duration.toFixed(2)}s (non-silent only)`);
                        const audioBuffer = createAudioBuffer(collectedFrames);
                        const wavBlob = audioBufferToWav(audioBuffer);
                        uploadToS3(wavBlob);
                        collectedFrames = [];
                        silenceDetected = false;
                        silenceStart = null;
                    }
                };
            } catch (err) {
                console.error('Error setting up audio pipeline:', err);
                alert('Failed to set up audio recording.');
                return;
            }

            if (!isRecording) {
                reconnectAttempts = 0;
                connectWebSocket();
                isRecording = true;
                recordBtn.textContent = 'Stop';
                saveBtn.disabled = false;
                drawWave();
            } else {
                isRecording = false;
                recordBtn.textContent = 'Record';
                processor.disconnect();
                sourceNode.disconnect();
                processor.onaudioprocess = null;
                // Upload remaining frames immediately
                if (collectedFrames.length > 0) {
                    const nonSilentFrames = filterNonSilent(collectedFrames);
                    if (nonSilentFrames.length > 0) {
                        const duration = (nonSilentFrames.length / audioContext.sampleRate);
                        console.log(`Uploading final audio - Duration: ${duration.toFixed(2)}s (non-silent only)`);
                        const audioBuffer = createAudioBuffer(nonSilentFrames);
                        const wavBlob = audioBufferToWav(audioBuffer);
                        uploadToS3(wavBlob);
                    } else {
                        console.log('No non-silent audio to upload on stop');
                    }
                    collectedFrames = [];
                }
            }
        });

        // Handle save
        saveBtn.addEventListener('click', () => {
            if (isRecording) {
                // Stop recording and upload remaining frames
                isRecording = false;
                recordBtn.textContent = 'Record';
                processor.disconnect();
                sourceNode.disconnect();
                processor.onaudioprocess = null;
                if (collectedFrames.length > 0) {
                    const nonSilentFrames = filterNonSilent(collectedFrames);
                    if (nonSilentFrames.length > 0) {
                        const duration = (nonSilentFrames.length / audioContext.sampleRate);
                        console.log(`Uploading final audio - Duration: ${duration.toFixed(2)}s (non-silent only)`);
                        const audioBuffer = createAudioBuffer(nonSilentFrames);
                        const wavBlob = audioBufferToWav(audioBuffer);
                        uploadToS3(wavBlob);
                    } else {
                        console.log('No non-silent audio to upload on save');
                    }
                    collectedFrames = [];
                }
            }
            saveDialog.classList.remove('hidden');
        });

        // Confirm save
        confirmSaveBtn.addEventListener('click', () => {
            const recordingName = recordingNameInput.value.trim();
            if (recordingName) {
                // Send recording name via WebSocket
                const message = JSON.stringify({ action: 'saveRecording', name: recordingName });
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(message);
                    console.log(`Sent recording name: ${recordingName}`);
                } else {
                    console.error('WebSocket is not open');
                }
                saveDialog.classList.add('hidden');
                recordingNameInput.value = '';
                saveBtn.disabled = true;
                if (ws) ws.close();
            } else {
                alert('Please enter a recording name.');
            }
        });

        // Cancel save
        cancelSaveBtn.addEventListener('click', () => {
            saveDialog.classList.add('hidden');
            recordingNameInput.value = '';
        });

        // Filter non-silent frames
        function filterNonSilent(frames) {
            const windowSize = 4096;
            const nonSilentFrames = [];
            for (let i = 0; i < frames.length; i += windowSize) {
                const window = frames.slice(i, i + windowSize);
                if (window.length === windowSize) {
                    let sum = 0;
                    for (let j = 0; j < window.length; j++) {
                        sum += Math.abs(window[j]);
                    }
                    const meanAbs = sum / window.length;
                    if (meanAbs >= silenceThreshold) {
                        nonSilentFrames.push(...window);
                    }
                }
            }
            return nonSilentFrames;
        }

        // Create AudioBuffer
        function createAudioBuffer(samples) {
            const audioBuffer = audioContext.createBuffer(1, samples.length, audioContext.sampleRate);
            const channelData = audioBuffer.getChannelData(0);
            for (let i = 0; i < samples.length; i++) {
                channelData[i] = samples[i];
            }
            return audioBuffer;
        }

        // Convert AudioBuffer to WAV
        function audioBufferToWav(buffer) {
            const numChannels = 1;
            const sampleRate = 16000;
            const format = 1;
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const dataSize = buffer.length * numChannels * bytesPerSample;
            const bufferArray = new ArrayBuffer(44 + dataSize);
            const view = new DataView(bufferArray);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                const sample = buffer.getChannelData(0)[i];
                const val = Math.max(-1, Math.min(1, sample)) * 32767;
                view.setInt16(offset, val, true);
                offset += 2;
            }
            return new Blob([bufferArray], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Upload to S3
        async function uploadToS3(wavBlob) {
            const timestamp = Date.now();
            const s3Key = `${username}/${username}_${timestamp}.wav`;
            console.log(`Uploading ${s3Key} to S3...`);
            const response = await fetch('https://3d6vpnxe79.execute-api.us-east-1.amazonaws.com/prod/generate-presigned-url', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ key: s3Key, bucket: bucketName })
            });
            if (!response.ok) {
                console.error('Failed to fetch pre-signed URL:', response.statusText);
                console.error('This may be due to CORS issues. Ensure the API allows requests from your static site domain.');
                return;
            }
            const { url } = await response.json();

            const uploadResponse = await fetch(url, {
                method: 'PUT',
                body: wavBlob,
                headers: { 'Content-Type': 'audio/wav' }
            });
            if (!uploadResponse.ok) {
                console.error('Failed to upload to S3:', uploadResponse.statusText);
                return;
            }
            console.log(`Uploaded ${s3Key} to S3`);

            const s3Uri = `s3://${bucketName}/${s3Key}`;
            const message = JSON.stringify({ action: 'sendS3Uri', s3Uri: s3Uri });
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(message);
            } else {
                console.error('WebSocket is not open');
            }
        }

        // Draw wave
        function drawWave() {
            if (!isRecording) return;
            const canvasCtx = waveCanvas.getContext('2d');
            const WIDTH = waveCanvas.width;
            const HEIGHT = waveCanvas.height;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = 'rgb(0, 0, 255)';
            canvasCtx.beginPath();
            const sliceWidth = WIDTH * 1.0 / bufferLength;
            let x = 0;
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * HEIGHT / 2;
                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }
                x += sliceWidth;
            }
            canvasCtx.lineTo(WIDTH, HEIGHT / 2);
            canvasCtx.stroke();
            requestAnimationFrame(drawWave);
        }

        initialize();
    });
</script>
</body>
</html>